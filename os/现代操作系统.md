# 虚拟内存



## 基于分页的虚拟内存

- 页表是分页机制中的关键部分，记录虚拟也到物理页的映射
- 多级页表，用来满足虚拟内存的要求k级，一个虚拟地址包括虚拟页号和页内偏移量。
  - 虚拟页号分为k个部分
  - 虚拟页号i 对应该地址在第i级页表的中的索引。
  - 如果任意一级的某个条目为空，那么条目对应下一级页表也不需要存在
- AArch64 结构4级页表
  - 虚拟地址低48位参与地址翻译，页表级数位4级，虚拟页大小为4kb
  - 因为页的大小是4kb 2的12次方 = 4kb，那么 ，指针的后低12位可以作为 页内偏移量。
  - 整个页表的的起始地址在一个特殊的寄存器  页表基地址寄存器是 TTBR0_Linux ,0 级别只有一个页表。
  - 每个页表项占用8个字节，用于存储物理地址和相应的访问权限-
  - 8字节地址组成
    - 63到48位  全部为0或者1 硬件要求 可用空间到 2的48次方
    - 47 到 39位  这9在虚拟地址的0级页表的索引值
    -  38-30 位 9位在一级页表的索引值
    - 29-21 位，9位作为在2级页表的索引值
    - 20-12 位 这9位是在3级索引值
    - 11-0 位  页内偏移  4kb 4096 字节 2的12次方
  - mmu 翻译结果虚拟地址，先根据寄存器找到第0级页表，然后一直真正的物理表，然后找到根据页内偏移量找到结果
- TLB
  - transalation lookside buffer，TLB 加速虚拟页号作为键查询TLB的缓存项，找到直接对应的物理页号，无需再查询页表，
  - TLB 刷新，一致性问题
    - 两个不同的程序A，B 使用了同样的虚拟地址VA，但是对应不同的物理地址PA1和PA2，在进行进程切换的时候需要刷新TLB
      - 有进程切换的性能损失
    - 在AArch64体系结构上，应用程序和操作系统使用不同的页表，不过由于有TTBR0—EL1 和 TTBR1—EL1 两个不同的页表基地址寄存器，因此在系统调用过程中不需要切换页表（我认为因为一条虚拟内存只有一个缓存，不会有二义性）。
    - 但是在应用程序切换会有tlb 刷新
- 换页和缺页异常
  -   换页 就是把一个物理页上的内容放在磁盘上
  - 缺页异常    会触发缺页异常， 异常处理函数起作用，（也可以是通过换页的方式）找到一个空闲的物理页，把之前写到磁盘上的重新加载，这过程被称为换入，然后回到发生的地方继续。
- 虚拟内存
  - 共享内存，允许一个物理页在不同的应用程序共享，
  - 写时拷贝 相同的内存数据 在物理内存中仅存一份，然后只读方式映射两个应用程序（比如共享库）



# 进程与线程

上下文切换

### 进程

- 新生状态
- 预算状态
- 运行状态
- 阻塞状态
- 终止状态

## 进程的内存空间布局

- 用户栈  用了自顶向下，一个一个栈一直压进去
- 代码库，进程执行需要依赖共享的代码库   libc，
- 用户堆，堆管理都的是进程动态分配的内存，与栈相反，自底向上
- 数据与代码段  
- 内核部分，处于进程地址空间最顶端的是内核内存，每个进程的虚拟地址空间都映射了相同的内核内存。

进程空间从上到下是

- 内核代码和数据 1G
- 内核栈
- 用户栈
- 代码库
- 用户堆
- 数据
- 代码

### 进程控制块和上下文切换

- PID 进程标识符  进程状态，虚拟内存状态，打开的文件

  ```
  volatile long state // 进程状态
  struct mm_struct *mm  // 虚拟内存状态
  pid_T pid // 进程标识符
  pid_t tgid // 进程组标识符
  struct task_struct __rcu *parent // 进程间关系
  struct list_head children
  stuct files_struct *files 打开的文件
  ```

  

### 进程上下文

- 包括 进程运行时的寄存器状态 用于保存和恢复一个进程在处理器运行的状态，把进程寄存器保存到PCB

- 保存和恢复作用

  - 进程1  切换到内核态 上下文保存到PCB1 
  - 恢复PCB2 上下文
  - 然后进程1，直到被中断或者系统调用被唤醒
  - 上下文保存到PCB2
  - 恢复PCB1

- Linux 进程操作

  - fork 从别的进程赋值

    - 父进程和子进程 得到的结果不一样

  -  exec exec接口 

    ```
    # include<unistd.h>
    
    int execve(const char *pathname, char *const argv[], char *const envp[])
    execve
    ```

    这里的path 是可执行文件的路径

  - wait 操作可以对子进程进行监控，

    - waitpid 可以等子进程完结

  - 进程组和会话

    - 进程组是进程的集合，在默认情况下，父进程和子进程属于同一个进程组，可以用 setpgid 创建新的移出去
    - 会话 是进程组的集合，由一个或者多个进程组成   

- POSIX 线程库为例

  - 线程创建

    - Pthread_create 创建一个新的线程， 并运行第三个参数 start_routine 指定的函数
    - pthread create 使用是clone 系统调用   

  - 线程退出和挂起

    - pthread exit 会隐式调用

    - pthread yield 允许使用yield 自动挂起

  - 合并操作

    - pthread join 就是支持合并操作

  - yield 和 sleep的区别，都会放弃cpu 资源交给其他线程执行，当调用yield之后 会处于预备状态，能够很快被调度

    - sleep 会进入阻塞状态，只有条件满足之后吗，才会进入预备状态

- 协程

  - 线程的切换会触发 上下文切换，但是因为在计算机上存在很多程序，可能会由调度器的开销

  - POSIX 协程支持

    - ucontext

    - ```
      int getcontext(ucontext_t *ucp)
      int setcontext(const ucontext_t *ucp)
      void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...)
      ```

    - get context  用于保存当前上下文，而setcontext 则可以用来切换到另一个上下文，

    - makecontext 是创建一个新的上下文

  - 协程的上下文

    - 操作系统可以通过中断的方式抢占cpu 且切换上下文，这种是强制的

    - 协程不具备使用终端抢占其他协程的权限，所以一般提供yield 接口

      ```
      setcontxt 原理
      // 恢复被调用者的通过寄存器
      // 恢复栈
      // 恢复浮点寄存器和参数
      // 恢复pC(program count函数计数器)并返回
      ```



## 同步原语

### 单生产者消费者模型

- 维持两个全局计数器 filled_slot 和 empty_slot ，当生产者需要放入缓冲区时候，先检查empty_slot 如果没了，要等有了

#### 互斥锁

- 互斥访问
- 有限等待
- 空闲让进

##### 硬件实现

- 在单核系统中，关闭中断，可以保证临界区的线程不会被抢占，避免多个线程同时进入临界区
- 多核系统两个线程，皮特森算法 ，
  - 维护一个全局数据 flag，flag[0] 和 flag[1] 代表线程0和1 是否尝试进入临界区，第二个是全局变量turn
  - 1的进入条件是 flag[1] 为ture turn =1 否则循环等待
  - 线程会设置自己的flag 为true 设置turn 为对方

- 软硬件协同 使用原子操作实现互斥锁
  - 原子操作，cas fetchAndAdd
  - 互斥锁的具体实现
    - 自旋锁
    - 排号自旋锁，就是每个人有一个序号，拍好获取
- 条件变量
  - 